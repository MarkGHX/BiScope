[
    "from typing import List\n\ndef elements_within_threshold(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Determine if any two numbers within the provided list are closer to each other than the specified threshold.\n    >>> elements_within_threshold([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> elements_within_threshold([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, number in enumerate(numbers):\n        for j, other_number in enumerate(numbers):\n            if i != j:\n                distance = abs(number - other_number)\n                if distance < threshold:\n                    return True\n    return False",
    "from typing import List\n\ndef extract_parenthetical_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    grouped_parens = []\n    current_group = []\n    nesting_level = 0\n    for char in paren_string:\n        if char == '(':\n            nesting_level += 1\n            current_group.append(char)\n        elif char == ')':\n            nesting_level -= 1\n            current_group.append(char)\n            if nesting_level == 0:\n                grouped_parens.append(''.join(current_group))\n                current_group = []\n\n    return grouped_parens",
    "Given a positive floating-point number, this number can be separated into two distinct components: the integer portion (the largest whole number less than the given number) and the decimal component (the fractional part consistently lesser than 1).\n\nThis function returns the decimal fraction of the provided number.",
    "Are there any transactions that put the balance below zero?",
    "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given collection of numbers, this function computes the Mean Absolute Deviation\n    centered around the average of these values.\n    Mean Absolute Deviation represents the typical distance between each value\n    and the mean, indicating variability:\n    MAD = mean of | x - mean(x) |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    average = sum(numbers) / len(numbers)  # Calculate the mean of the input numbers\n    return sum(abs(x - average) for x in numbers) / len(numbers)  # Compute MAD\n",
    "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    if not numbers:\n        return []\n    interspersed = []\n    for number in numbers[:-1]:\n        interspersed.append(number)\n        interspersed.append(delimiter)\n    interspersed.append(numbers[-1])\n    return interspersed",
    "from typing import List\n\ndef analyze_nested_parentheses(parentheses_string: str) -> List[int]:\n    def evaluate_parentheses_group(s: str) -> int:\n        depth = 0\n        maximum_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                maximum_depth = max(maximum_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return maximum_depth\n    \n    return [evaluate_parentheses_group(group) for group in parentheses_string.split(' ')]",
    "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Sift through a list of strings, keeping only those that encompass the specified substring.\n    \n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [x for x in strings if substring in x]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from typing import List, Tuple\n\ndef calculate_sum_and_product(numbers: List[int]) -> Tuple[int, int]:\n    total_sum = 0\n    total_product = 1\n    for num in numbers:\n        total_sum += num\n        total_product *= num\n    return (total_sum, total_product)",
    "def calculate_rolling_maximum(values: List[int]) -> List[int]:\n    current_maximum = None\n    outcomes = []\n    for value in values:\n        if current_maximum is None or value > current_maximum:\n            current_maximum = value\n        outcomes.append(current_maximum)\n    return outcomes",
    "def is_palindrome(string: str) -> bool:\n    \"\"\" Check if the provided string is a palindrome \"\"\"\n    normalized_string = ''.join(character.lower() for character in string if character.isalnum())  # Normalize the string\n    return normalized_string == normalized_string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Craft the shortest palindrome beginning with the given string.\n    The strategy is straightforward:\n    - Identify the longest suffix of the given string that forms a palindrome.\n    - Extend the initial string by appending the reverse of the prefix that precedes the palindromic suffix.\n    \"\"\"\n    if not string:\n        return ''\n    length = len(string)\n    for index in range(length):\n        if is_palindrome(string[index:]):\n            return string + string[:index][::-1]\n    return string  # This scenario technically won't occur due to the logic of the loop",
    "def bitwise_xor_strings(a: str, b: str) -> str:\n    def xor_pairs(i: str, j: str) -> str:\n        return '0' if i == j else '1'\n    \n    return ''.join(xor_pairs(x, y) for x, y in zip(a, b))",
    "from typing import List, Optional\n\ndef get_longest_string(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Identifies and returns the longest string from a provided list of strings.\n    When there are multiple strings with identical maximum length, it returns the first occurrence.\n    Returns None if the given list is empty.\n\n    Example usage:\n    >>> get_longest_string([])\n    \n    >>> get_longest_string(['a', 'b', 'c']) \n    'a' \n    >>> get_longest_string(['a', 'bb', 'ccc']) \n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    max_length = max(len(string) for string in strings)\n    for string in strings:\n        if len(string) == max_length:\n            return string\n",
    "Calculate the highest common factor of two integers, a and b.",
    "from typing import List\n\ndef gather_all_prefixes(text: str) -> List[str]:\n    \"\"\"Generate a list containing all prefixes of the provided text, arranged from the shortest to the longest.\n    >>> gather_all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = []\n    for i in range(len(text)):\n        prefixes.append(text[:i+1])\n    return prefixes",
    "Create a sequence of strings from numbers.",
    "Calculate the number of unique characters in a string.",
    "def extract_notes_from_music(melody: str) -> List[int]:\n    notes_dictionary = {'o': 4, 'o|': 2, '.|': 1}\n    return [notes_dictionary[note] for note in melody.split(' ') if note in notes_dictionary]",
    "def count_occurrences(text: str, pattern: str) -> int:\n    occurrences = 0\n    for i in range(len(text) - len(pattern) + 1):\n        if text[i:i+len(pattern)] == pattern:\n            occurrences += 1\n    return occurrences\n\n# Running doctests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "Transform a space-separated string of spelled-out numbers, ranging from 'zero' to 'nine', into an ascending order. Allowable inputs encompass 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', and 'nine'. The function returns the sequence arranged from the lowest to the highest value.\nFor instance, `sort_numbers('three one five')` yields 'one three five'.",
    "from typing import List, Tuple\n\ndef find_nearest_elements(values: List[float]) -> Tuple[float, float]:\n    nearest_pair = (0, 0)  # Initial placeholder for the pair with the smallest gap\n    gap = None  # Placeholder for the minimum gap, None means it's yet to be determined\n    values.sort()  # Sorting the values first to ensure efficiency in discovering the nearest pair\n    \n    # Iterate through the list, now in ascending order\n    for i in range(len(values) - 1):\n        # Find the gap between successive elements\n        current_gap = values[i+1] - values[i]\n        \n        # If this is either the first pair or a pair with a smaller gap, update our records\n        if gap is None or current_gap < gap:\n            gap = current_gap\n            nearest_pair = (values[i], values[i+1])\n            \n    return nearest_pair\n",
    "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (at least two elements), the function performs a linear transformation,\n    causing the smallest number to be converted to 0 and the largest to 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]",
    "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter the provided list of various Python values, retaining only the integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [x for x in values if isinstance(x, int)]",
    "Calculate the number of characters in the provided text.",
    "For a given number n, this function identifies the greatest number less than n that divides n without leaving a remainder.",
    "def decompose_into_factors(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors",
    "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    count = Counter(numbers)\n    return [number for number in numbers if count[number] == 1]",
    "For a provided string, this function switches lowercase letters to uppercase and uppercase letters to lowercase.\n>>> flip_case('Hello')\n'hELLO'",
    "Merge a sequence of strings into one continuous string.",
    "Enhance the word choices in the sentence to sound more like that of a human, no explain.\n\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter a given list of strings to include only those that begin with a specified prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [x for x in strings if x.startswith(prefix)]",
    "Extract exclusively the positive integers from a collection, omitting any negative figures.",
    "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for k in range(3, int(n ** 0.5) + 1, 2):\n        if n % k == 0:\n            return False\n    return True",
    "import math\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Calculates the value of a polynomial with coefficients 'xs' at point 'x'.\n    It returns the sum of each coefficient multiplied by 'x' raised to the power of its index.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\" \n    Identifies a zero point of a polynomial characterized by the coefficients 'xs'.\n    It assumes the polynomial possesses at least one real root and has an even count of coefficients.\n    \"\"\"\n    # Setting the initial search range\n    begin, end = -1.0, 1.0\n    \n    # Extending the search range until a change in sign is detected\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2\n        end *= 2\n    \n    # Employing binary search to pinpoint the root\n    while abs(end - begin) > 1e-10:\n        middle = (begin + end) / 2\n        if poly(xs, middle) * poly(xs, begin) < 0:\n            end = middle\n        else:\n            begin = middle\n    \n    return (begin + end) / 2\n\n# Demonstrating test cases\nif __name__ == \"__main__\":\n    # Executing test cases as specified\n    print(\"Root identified (approximation):\", round(find_zero([1, 2]), 2))  # Anticipated result: -0.5\n    print(\"Root identified (approximation):\", round(find_zero([-6, 11, -6, 1]), 2))  # Anticipated result: 1.0\n",
    "Refine the elements at every third position in the list by sorting them, while keeping the rest of the list unchanged.",
    "This function returns a sorted list of the distinct elements present in the input list.",
    "Find the largest value within the list.\n    >>> find_largest_value([1, 2, 3])\n    3\n    >>> find_largest_value([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123",
    "The function `fizz_buzz` takes an integer `n` and generates a list of integers less than `n` that are divisible by either 11 or 13. It then creates a string by concatenating these numbers and calculates the total occurrences of the digit '7' within this string, returning this count.",
    "def sort_even_elements(l: list):\n    even_indices_elements = l[::2]\n    odd_indices_elements = l[1::2]\n    even_indices_elements.sort()\n    sorted_list = []\n    for i in range(max(len(even_indices_elements), len(odd_indices_elements))):\n        if i < len(even_indices_elements):\n            sorted_list.append(even_indices_elements[i])\n        if i < len(odd_indices_elements):\n            sorted_list.append(odd_indices_elements[i])\n    return sorted_list",
    "The `decode_cyclic` function accepts a string that has been encrypted using the `encode_cyclic` method and returns the decrypted string. To achieve this, the function cleverly applies the `encode_cyclic` method twice, effectively reversing the cyclical permutation and revealing the original text.",
    "more human-like version of your code explanation:\n\n```python\nimport math\n\ndef prime_fib(n: int):\n    # Define a helper function to check if a number is prime.\n    def is_prime(p):\n        # Return False if the number is less than 2, as it's not prime.\n        if p < 2:\n            return False\n        # Check divisibility of p by any number up to its square root.\n        for i in range(2, int(math.sqrt(p)) + 1):\n            if p % i == 0:\n                return False\n        return True\n\n    # Initialize the Fibonacci sequence list with the first two numbers.\n    f = [0, 1]\n    count = 0  # Initialize the count of prime numbers found.\n    \n    # Use a loop to keep generating Fibonacci numbers until the condition is met.\n    while True:\n        # Ensure the Fibonacci list only holds the last two numbers.\n        if len(f) > 2:\n            f.pop(0)\n        f.append(f[-1] + f[-2])  # Calculate the next Fibonacci number.\n        \n        # If the newly added Fibonacci number is prime, increase the count.\n        if is_prime(f[-1]):\n            count += 1\n            # If we've found the nth prime Fibonacci number, return it.\n            if count == n:\n                return f[-1]\n",
    "This function looks for any three unique elements within the list that, when added together, equal zero.",
    "Calculate the number of possible collisions in a car race.",
    "def increment_elements_in_list(input_list: list):\n    \"\"\"Return a list with its elements incremented by 1.\n    >>> increment_elements_in_list([1, 2, 3])\n    [2, 3, 4]\n    >>> increment_elements_in_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [element + 1 for element in input_list]",
    "The given function checks if there are any two numbers in a list that add up to zero.",
    "Convert the numerical value to a specified base, concatenating digits until completion.",
    "Given the length of a side and height, return the area of a triangle.",
    "To calculate the fourth step in the Fibonacci sequence for a given number \\(n\\), we commence by determining if \\(n\\) is less than 4. If so, we promptly return the corresponding value from the predefined list \\([0, 0, 2, 0]\\). \n\nFor \\(n\\) values of 4 or higher, we initialize our sequence with the starting list \\([0, 0, 2, 0]\\). Then, we embark on a journey from 4 up to \\(n\\), inclusively. In each iteration, we calculate the next Fibonacci number by summing the current elements in our list. To maintain the sequence's integrity and progress, we remove the first element and add the newly calculated Fibonacci number at the end of our list.\n\nUpon reaching the culmination of our loop, we retrieve and return the last element from our list, representing the sought-after Fibonacci number for the input \\(n\\).",
    "def find_median(values: list):\n    \"\"\"Calculate the median value of elements in the list.\n    >>> find_median([3, 1, 2, 4, 5])\n    3\n    >>> find_median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    values = sorted(values)\n    if len(values) % 2 == 1:\n        return values[len(values) // 2]\n    else:\n        return (values[len(values) // 2 - 1] + values[len(values) // 2]) / 2.0",
    "Evaluates if a provided string is a palindrome",
    "def compute_power_modulo(n: int, p: int) -> int:\n    \"\"\"Calculate 2 to the power of n modulo p with attention to numeric stability.\n    >>> compute_power_modulo(3, 5)\n    3\n    >>> compute_power_modulo(1101, 101)\n    2\n    >>> compute_power_modulo(0, 101)\n    1\n    >>> compute_power_modulo(3, 11)\n    8\n    >>> compute_power_modulo(100, 101)\n    1\n    \"\"\"\n    result = 1\n    for _ in range(n):\n        result = (2 * result) % p\n    return result\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "This function accepts a string that has been encrypted with the encode_shift function and returns the decrypted string.",
    "def eliminate_vowels(text):\n    return ''.join(char for char in text if char.lower() not in 'aeiou')",
    "Determine if all elements in a list are less than a specified threshold.",
    "Sum together two integers x and y\n    >>> calculate the sum of 2 and 3\n    5\n    >>> calculate the sum of 5 and 7\n    12",
    "def share_identical_characters(string1: str, string2: str) -> bool:\n    return set(string1) == set(string2)\n\n# Tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def fib(n: int):\n    \"\"\"Calculate the n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)",
    "def is_bracket_sequence_correct(brackets: str) -> bool:\n    nesting_level = 0\n    for symbol in brackets:\n        if symbol == \"<\":\n            nesting_level += 1\n        elif symbol == \">\":\n            nesting_level -= 1\n        if nesting_level < 0:\n            return False\n    return nesting_level == 0",
    "def is_monotonic(sequence: list):\n    return sequence == sorted(sequence) or sequence == sorted(sequence, reverse=True)",
    "version that might feel more warm and personable:\n\n```python\ndef findCommonElements(list1: list, list2: list) -> list:\n    \"\"\"Return a sorted list of unique elements that appear in both input lists.\n    >>> findCommonElements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> findCommonElements([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(list1).intersection(set(list2)))\n",
    "def find_largest_prime_factor(number: int) -> int:\n    \"\"\"Calculate the largest prime factor of a given number. Assumes the number is greater than 1 and not a prime itself.\n    >>> find_largest_prime_factor(13195)\n    29\n    >>> find_largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(candidate: int) -> bool:  # Checks if a number is prime\n        if candidate < 2:\n            return False\n        for divisor in range(2, int(candidate ** 0.5) + 1):\n            if candidate % divisor == 0:\n                return False\n        return True\n    \n    largest_prime = 1  # Initialize the largest prime factor\n    for possible_factor in range(2, number + 1):\n        if number % possible_factor == 0 and is_prime(possible_factor):\n            largest_prime = max(largest_prime, possible_factor)\n    return largest_prime\n",
    "\"sum_to_n is a function designed to calculate the total sum of all integers from 1 up to and including n.",
    "Is the bracket sequence properly balanced? This function determines if the parentheses are correctly nested. It keeps track of the nesting depth as it scans through the sequence. If it encounters an open parenthesis, it increases the depth; for a closing one, it decreases the depth. A negative depth indicates a closing parenthesis without a matching open one, leading to an immediate false result. If the entire sequence is processed without issues and the final depth is zero, it means every open parenthesis was properly closed, thus the sequence is balanced.",
    "Calculate the derivative of a list of coefficients by multiplying each element by its index, starting from the second element.",
    "To calculate the value of an element in a Fibonacci sequence, where each number is the sum of the three preceding ones, starting from two predefined zeros and one, you can use the following function. If the value for a given position is already computed and stored, the function immediately returns this value. Otherwise, it computes the value by recursively summing up the values of the three preceding positions, caching the result for future reference. This method efficiently reduces the number of calculations needed, leveraging memorization to avoid redundant processing.",
    "nd the array of test scenarios.\n```\n\n```python\ndef count_vowels(input_str):\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for character in input_str if character in vowels)\n    if input_str[-1] in \"yY\":\n        count += 1\n    return count\n\n# Test scenarios\nprint(count_vowels(\"abcde\"))  # Expected result: 2\nprint(count_vowels(\"ACEDY\"))  # Expected result: 3\nprint(count_vowels(\"python\")) # Expected result: 1\nprint(count_vowels(\"Rhythm\")) # Expected result: 0\nprint(count_vowels(\"SYZYGY\")) # Expected result: 1\n",
    "def rotate_string(text, shift_amount):\n    s = str(text)\n    if shift_amount > len(s):\n        return s[::-1]\n    return s[len(s) - shift_amount:] + s[:len(s) - shift_amount]",
    "Calculate the sum of ASCII values of all uppercase letters in the given string.",
    "def calculateFruitRemaining(sentence, totalFruits):\n    numbersList = []\n    for word in sentence.split(' '):\n        if word.isdigit():\n            numbersList.append(int(word))\n    return totalFruits - sum(numbersList)",
    "def findSmallestEven(arr):\n    if not arr:  # Verify the array isn't empty\n        return []\n    evenNumbers = list(filter(lambda x: x % 2 == 0, arr))  # Extract only the even numbers\n    if not evenNumbers:  # Confirm there are even numbers present\n        return []\n    smallestEven = min(evenNumbers)  # Determine the smallest even number\n    return [smallestEven, arr.index(smallestEven)]  # Return the number and its position",
    "To find the first number that appears in the list at least as many times as its value, follow these steps. First, initialize a frequency array that accommodates all values from the list, ensuring no value is omitted. Then, iterate through the list, incrementing the count in the frequency array for each number encountered. Finally, traverse the frequency array starting from the smallest possible number, and identify the first occurrence where the frequency of a number is at least equal to its value. This identified number will be your answer. If no such number is found, the result will remain as -1.",
    "def zigzag_sort_list(lst):\n    result = []\n    toggle = True\n    while lst:\n        if toggle:\n            result.append(min(lst))\n            lst.remove(min(lst))\n        else:\n            result.append(max(lst))\n            lst.remove(max(lst))\n        toggle = not toggle\n    return result",
    "ython\nimport math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle, this function calculates and \n    returns the area of the triangle rounded to 2 decimal places, provided the sides \n    form a valid triangle. If the sides do not form a valid triangle, it returns -1.\n    '''\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    else:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n",
    "def will_it_fly(objects, max_weight):\n    # Calculate the sum of objects' weights\n    total_weight = sum(objects)\n    \n    # Verify if the total weight surpasses the maximum permissible weight\n    if total_weight > max_weight:\n        return False\n    \n    # Evaluate if the list of objects forms a palindrome\n    start, end = 0, len(objects) - 1\n    while start < end:\n        if objects[start] != objects[end]:\n            return False\n        start += 1\n        end -= 1\n    \n    # Reaching here means the object's weight is within limits and it's symmetrically balanced\n    return True",
    "Find the minimum number of modifications needed.",
    "To calculate the combined character count for each list, we'll start off by setting the total count for both lists to zero. \n\nNext, we'll tally up the total number of characters in the first list by iterating through each string and adding its length to our ongoing total.\n\nWe'll follow the same procedure for the second list, ensuring we accurately capture the total character count there as well.\n\nFinally, we'll compare the total character counts of both lists. If the first list has fewer characters or if both lists have an equal number of characters, we'll return the first list. Otherwise, the second list, having fewer characters, will be returned.",
    "Does the number factor into three distinct primes? Consider a methodology to determine if a number breaks down into the product of three prime numbers. Start by inspecting each number's prime nature within a defined scope. If a trio of prime numbers multiplied together equals the target, then we've found our unique combination.",
    "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    accumulated_power = 1\n    while accumulated_power < x:\n        accumulated_power *= n\n    return accumulated_power == x",
    "def isCube(num):\n    root = round(abs(num) ** (1. / 3))\n    return root ** 3 == abs(num)",
    "def countPrimeDigit(num):\n    primeDigits = ('2', '3', '5', '7', 'B', 'D')\n    count = 0\n    for digit in num:\n        if digit in primeDigits:\n            count += 1\n    return count",
    "def convert_decimal_to_binary(decimal_number):\n    return \"db\" + bin(decimal_number)[2:] + \"db\"",
    "Can the given string be considered content? If its length is less than three characters, it cannot. To assess happiness, examine each character in succession \u2014 if a character matches its immediate neighbor or the one next to that, or if two consecutive characters are identical, then the string doesn\u2019t qualify as content. If none of these conditions apply, the string indeed passes as content.",
    "def convert_gpa_to_letter_grades(grades):\n    letter_grades_output = []\n    for gpa in grades:\n        if gpa == 4.0:\n            grade = 'A+'\n        elif gpa > 3.7:\n            grade = 'A'\n        elif gpa > 3.3:\n            grade = 'A-'\n        elif gpa > 3.0:\n            grade = 'B+'\n        elif gpa > 2.7:\n            grade = 'B'\n        elif gpa > 2.3:\n            grade = 'B-'\n        elif gpa > 2.0:\n            grade = 'C+'\n        elif gpa > 1.7:\n            grade = 'C'\n        elif gpa > 1.3:\n            grade = 'C-'\n        elif gpa > 1.0:\n            grade = 'D+'\n        elif gpa > 0.7:\n            grade = 'D'\n        elif gpa > 0.0:\n            grade = 'D-'\n        else:\n            grade = 'F'\n        letter_grades_output.append(grade)\n    return letter_grades_output",
    "def is_prime_length(string):\n    length = len(string)\n    \n    if length < 2:\n        return False\n    \n    for num in range(2, int(length**0.5) + 1):\n        if length % num == 0:\n            return False\n        \n    return True",
    "Given a positive integer n, this function calculates the total number of n-digit positive integers that either begin or conclude with the digit 1.",
    "def calculateBinarySumOfDigits(N):\n    totalSumOfDigits = sum(int(digit) for digit in str(N))\n    return bin(totalSumOfDigits)[2:]",
    "\"\"\"Provided a non-empty list of integers `lst`, compute the sum of the even elements that are positioned at odd indices.\n\nExamples:\n    add([4, 2, 6, 7]) ==> 2\n\"\"\"",
    "To create an anti-shuffle function for a string:\n- Begin by dividing the string into individual words.\n- For each word, organize the characters in ascending order based on their ASCII values and then reconstruct the word.\n- Finally, reunite the organized words into a single string, using a space as the delimiter.",
    "Retrieve the coordinates of the value x within the list, sorting them primarily by their row position and secondarily in descending order by their column position.",
    "def sort_array(array):\n    if len(array) == 0:\n        return []\n    return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",
    "To scramble(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'  # Define the alphabet\n    result = ''  # Begin with an empty result string\n    for char in s:  # Iterate over each character in the input string\n        if char in alphabet:  # Verify if the character is a lowercase letter\n            index = alphabet.index(char)  # Determine the character's position in the alphabet\n            newIndex = (index + 4) % 26  # Compute the new position with wrap-around\n            result += alphabet[newIndex]  # Add the transformed character to the result string\n        else:\n            result += char  # Append characters that aren't lowercase letters without changes\n    return result",
    "def find_second_smallest(numbers):\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]",
    "import re\n\ndef is_bored(text):\n    sentences = re.split(r'[.?!]\\s*', text)\n    return sum(sentence.startswith('I ') for sentence in sentences if sentence)\n\n# Example usage:\nprint(is_bored(\"I am bored. This is great! I don\u2019t think so. What? I see.\"))",
    "This function checks if any combination of adding two of the provided integer variables equals the third one.",
    "def encrypt(text):\n    modified_vowels = {vowel: chr(ord(vowel) + 2) for vowel in \"aeiouAEIOU\"}\n    modified_vowels.update({vowel.upper(): chr(ord(vowel.upper()) + 2) for vowel in \"aeiou\"})\n    text = text.swapcase()\n    encrypted_text = \"\"\n    for character in text:\n        if character in modified_vowels:\n            encrypted_text += modified_vowels[character]\n        else:\n            encrypted_text += character\n    return encrypted_text",
    "def findMaxPrimeDigitSum(numbers):\n    def isPrime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    highestPrime = -1\n    for num in numbers:\n        if isPrime(num) and num > highestPrime:\n            highestPrime = num\n\n    if highestPrime == -1:  # No prime number found\n        return 0\n    else:\n        return sum([int(digit) for digit in str(highestPrime)])",
    "def validate_dictionary_case(dictionary):\n    if not dictionary:\n        return False\n\n    state = \"start\"\n\n    for key in dictionary.keys():\n        if not isinstance(key, str):\n            return False\n        if state == \"start\":\n            if key.isupper():\n                state = \"upper\"\n            elif key.islower():\n                state = \"lower\"\n            else:\n                return False\n        elif state == \"upper\" and not key.isupper():\n            return False\n        elif state == \"lower\" and not key.islower():\n            return False\n\n    return True",
    "def generate_primes_up_to(n):\n    primes_list = []\n    for num in range(2, n):\n        is_prime = True\n        for divisor in range(2, num):\n            if num % divisor == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes_list.append(num)\n    return primes_list",
    "Refine the function to multiply the last digits of two numbers, ensuring the product of their ones place is returned. It's designed to handle any pair of integers, delivering accurate results even with negative numbers. For illustration:\n- When processing `multiply(148, 412)`, the result should be 16.\n- Invoking `multiply(19, 28)` is expected to yield 72.\n- Calling `multiply(2020, 1851)` will produce 0.\n- Engaging `multiply(14, -15)` outputs 20.",
    "To calculate the number of uppercase vowels at even positions in a string, initiate a counter at zero. Define the vowels of interest as 'AEIOU'. Iteratively check each character at even indexes within the string, incrementing the counter whenever an uppercase vowel is encountered. Finally, return the total count.",
    "from math import ceil, floor\n\ndef nearest_integer(value):\n    if not value:\n        return 0\n\n    if '.' in value:\n        value = value.rstrip('0').rstrip('.')\n    \n    try:\n        number = float(value)\n    except ValueError:\n        return 0\n\n    if value.endswith('.5'):\n        if number > 0:\n            return ceil(number)\n        else:\n            return floor(number)\n    else:\n        return round(number)",
    "Create a sequence by adding increasing even numbers to the initial value.",
    "To transform the string, the function first checks if it's empty, returning an empty list if true. If not, it iterates through each character, replacing commas with spaces, and then splits the modified string into a list of words.",
    "This function, named `choose_num`, is designed to find and return the largest even integer between two given positive integers, inclusive. Specifically, it accepts two parameters, `x` and `y`, and performs the task of identifying the maximum even number in the range starting from `x` to `y`. If such a number doesn't exist within the specified range, or if the first parameter is greater than the second (indicating a range that doesn't progress naturally), the function is programmed to return -1 as an indication of failure to meet the criteria.\n\nFor instance, when supplied with the range 12 to 15, the function smartly determines 14 to be the largest even number fitting the criteria and returns it. Conversely, if the function encounters a situation where the range is reversed or doesn't contain any even numbers, such as from 13 to 12, it promptly returns -1, signaling the absence of a suitable even number within the range.",
    "def calculateRoundedAverage(start, end):\n    if end < start:\n        return -1\n    total = sum(range(start, end+1))\n    average = total / (end - start + 1)\n    rounded_average = round(average)\n    binary_representation = bin(rounded_average)\n    return binary_representation",
    "def find_unique_odd_digits(x):\n    elements_with_odd_digits = []\n    for item in x:\n        if all(int(char) % 2 != 0 for char in str(item)):\n            elements_with_odd_digits.append(item)\n    return sorted(elements_with_odd_digits)",
    "def sort_by_length(arr):\n    number_to_word = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    sorted_arr = []\n    arr.sort(reverse=True)\n    for num in arr:\n        try:\n            word = number_to_word[num]\n            sorted_arr.append(word)\n        except KeyError:\n            continue\n    return sorted_arr",
    "The function `f(n)` generates a list that contains either the factorial of even numbers or the sum of all integers up to an odd number, for each number in the sequence from 1 up to `n`. For every even number `i`, the function computes its factorial by multiplying all integers from 1 to `i`. For every odd number `i`, the function calculates its cumulative sum by adding together all integers from 1 to `i`. It then appends the result of either operation to a list, which is returned at the end.",
    "def count_even_odd_palindromes(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    count_of_even_palindromes = 0\n    count_of_odd_palindromes = 0\n\n    for number in range(1, n+1):\n        if is_palindrome(number):\n            if number % 2 == 0:\n                count_of_even_palindromes += 1\n            else:\n                count_of_odd_palindromes += 1\n\n    return count_of_even_palindromes, count_of_odd_palindromes",
    "def positive_digit_sum_count(array):\n    def sum_of_digits(number):\n        sign = 1\n        if number < 0:\n            sign = -1\n            number *= -1\n        digits = [int(digit) for digit in str(number)]\n        digits[0] *= sign\n        return sum(digits)\n\n    return len([element for element in array if sum_of_digits(element) > 0])",
    "def can_reorder_by_moving_one_ball(arr):\n    if not arr:\n        return True\n    \n    sorted_arr = sorted(arr)\n    smallest_value = min(arr)\n    smallest_index = arr.index(smallest_value)\n    \n    rearranged_arr = arr[smallest_index:] + arr[:smallest_index]\n    \n    for i in range(len(arr)):\n        if rearranged_arr[i] != sorted_arr[i]:\n            return False\n            \n    return True",
    "def swap_check(lst1, lst2):\n    odd_count = 0\n    even_count = 0\n    for number in lst1:\n        if number % 2 != 0:\n            odd_count += 1\n    for number in lst2:\n        if number % 2 == 0:\n            even_count += 1\n    if even_count >= odd_count:\n        return \"YES\"\n    else:\n        return \"NO\"",
    "def histogram(sample_text):\n    from collections import Counter\n    \n    if not sample_text.strip():\n        return {}  # Return an empty dictionary if the input string is empty or only contains spaces.\n    \n    result_dict = {}\n    words_list = sample_text.split()\n    \n    # Creating a counter object to tally occurrences of each word.\n    word_counts = Counter(words_list)\n    \n    # Determining the highest occurrence count.\n    max_count = max(word_counts.values())\n    \n    # Identifying words that have the highest occurrence and adding them to the result dictionary.\n    for word, count in word_counts.items():\n        if count == max_count:\n            result_dict[word] = count\n    \n    return result_dict",
    "The function `reverse_delete` takes a string `s` and a character `c` as inputs, proceeding to create a resultant string that excludes all instances of `c`. It then checks whether this newly formed string is a palindrome\u2014a sequence that reads the same backward as forward. The function ultimately returns a tuple containing the processed string and a Boolean value indicating whether or not it is a palindrome.",
    "def count_odd_numbers(lists):\n    results = []\n    for array in lists:\n        count = sum(1 for digit in array if int(digit) % 2 == 1)\n        sentence = f\"The count of odd elements is {count} in the array, reflecting in the string as well as the input.\"\n        results.append(sentence)\n    return results",
    "refined version:\n\n```python\ndef findMinimumSubarraySum(numbers):\n    maximumNegativeSum = currentSum = 0\n    for number in numbers:\n        currentSum += -number\n        if currentSum < 0:\n            currentSum = 0\n        if currentSum > maximumNegativeSum:\n            maximumNegativeSum = currentSum\n    if maximumNegativeSum == 0:\n        maximumNegativeSum = max(-number for number in numbers)\n    minimumSum = -maximumNegativeSum\n    return minimumSum\n\n# Example usage\nprint(findMinimumSubarraySum([2, 3, 4, 1, 2, 4]))  # Output: 1\nprint(findMinimumSubarraySum([-1, -2, -3]))  # Output: -6\n",
    "Calculate the total number of fills needed for each container in the grid, given their capacities.",
    "The function `sort_array` takes an array `arr` and returns it sorted primarily by the number of ones in their binary representation and secondarily in ascending order.",
    "To refine the word choices for a more human-like sentence, the sentence could be phrased as:\n\n\"Create a function called select_words that takes a string s and an integer n as inputs. It initializes an empty list called result. The function then splits the string into words and defines a string of vowels for reference. For each word in the split string, it calculates the number of consonants by excluding the vowels and compares this number with n. If they match, the word is appended to the result list. Finally, the function returns the result list.\"\n\nThis version provides a more detailed and narratively engaging description of the function's operation.",
    "Identify the nearest vowel in a word, ensuring it's flanked by consonants.",
    "def parentheses_match(strings):\n\n    def is_balanced(sequence):\n        count = 0\n        for character in sequence:\n            if character == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    combined1 = strings[0] + strings[1]\n    combined2 = strings[1] + strings[0]\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'",
    "The code snippet defines a function called `maximum`, which takes in a list `arr` and an integer `k`. If `k` is zero, the function returns an empty list. First, the list `arr` is sorted in ascending order. Then, the function returns the last `k` elements of the sorted list, effectively retrieving the `k` largest elements from the original list.",
    "This function calculates the sum of odd numbers located at even indices within the given list.",
    "Calculate the sum of the first k elements in the array, provided their string representation does not exceed two characters.",
    "def find_odd_collatz_numbers(n):\n    odd_collatz_sequence = [n] if n % 2 != 0 else []\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n            if n != 1:  # Prevent adding 1 repeatedly\n                odd_collatz_sequence.append(n)\n    odd_collatz_sequence.append(1)  # Guarantee 1 is always included in the sequence\n    return sorted(odd_collatz_sequence)",
    "def is_date_valid(date):\n    # Trim leading and trailing spaces\n    date = date.strip()\n    \n    try:\n        # Break down the date string\n        month, day, year = date.split('-')\n        \n        # Convert to integer values\n        month = int(month)\n        day = int(day)\n        year = int(year)\n        \n    except ValueError:\n        # Return False if it fails to convert\n        return False\n    \n    # Validate the month\n    if month < 1 or month > 12:\n        return False\n    \n    # Validate the day based on the month\n    if month in [1, 3, 5, 7, 8, 10, 12] and (day < 1 or day > 31):\n        return False\n    elif month in [4, 6, 9, 11] and (day < 1 or day > 30):\n        return False\n    elif month == 2 and (day < 1 or day > 29):\n        return False\n    \n    # If all validations are passed, the date is considered valid\n    return True",
    "To dissect the input text, we commence by probing for spaces, opting to slice the text where these spaces occur. In the absence of spaces, we pivot to search for commas, substituting these with spaces to similarly segment the text. In scenarios devoid of both spaces and commas, our attention shifts to tallying specific lowercase alphabets characterized by their ASCII values being even. This meticulously designed algorithm not only caters to text segmentation but also to quantifying certain alphabetic attributes under specified conditions.\n\n# Demonstrating its application\nprint(split_words(\"Hello world!\"))  # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"Hello,world!\"))  # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"abcdef\"))  # \u279e 3",
    "def is_sorted(sequence):\n    digit_occurrences = {}\n    for item in sequence:\n        if item in digit_occurrences:\n            digit_occurrences[item] += 1\n        else:\n            digit_occurrences[item] = 1\n    if any(digit_occurrences[item] > 2 for item in sequence):\n        return False\n    if not all(sequence[i-1] <= sequence[i] for i in range(1, len(sequence))):\n        return False\n    return True",
    "def check_prime_interval_overlap(interval1, interval2):\n    def is_prime(number):\n        if number < 2:\n            return False\n        for i in range(2, int(number**0.5)+1):\n            if number % i == 0:\n                return False\n        return True\n\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    interval_length = end - start + 1\n\n    if interval_length > 0 and is_prime(interval_length):\n        return \"YES\"\n    else:\n        return \"NO\"",
    "def calculateProductSign(arr):\n    if not arr:\n        return None\n    if 0 in arr:\n        return 0\n    signOfProduct = (-1) ** len([num for num in arr if num < 0])\n    totalAbsoluteValues = sum(abs(num) for num in arr)\n    return signOfProduct * totalAbsoluteValues",
    "def findMinPath(grid, k):\n    from heapq import heappush, heappop\n    \n    size = len(grid)\n    moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # Directions: right, down, left, up\n    starting_points = []\n    \n    # Prepare to map each grid value to its location.\n    valueLocations = {}\n    for row in range(size):\n        for col in range(size):\n            valueLocations[grid[row][col]] = (row, col)\n\n    def getNeighbors(row, col):\n        \"\"\"Generates valid adjacent cells.\"\"\"\n        for dRow, dCol in moves:\n            newRow, newCol = row + dRow, col + dCol\n            if 0 <= newRow < size and 0 <= newCol < size:\n                yield newRow, newCol\n    \n    # Set up a priority queue with entries as tuples: (path_value_list, last_row, last_col)\n    priorityQueue = [([[grid[x][y]]], x, y) for x, y in valueLocations.values()]\n    \n    while priorityQueue:\n        currentPath, row, col = heappop(priorityQueue)\n        if len(currentPath) == k:\n            return currentPath[0]  # Return the found path of length k.\n        for neighborRow, neighborCol in getNeighbors(row, col):\n            newPath = currentPath[:]  # Duplicate the current path.\n            newPath[0].append(grid[neighborRow][neighborCol])\n            if len(newPath[0]) <= k:\n                heappush(priorityQueue, (newPath, neighborRow, neighborCol))\n    \n    return []  # Returns an empty list if no path is found, which is unlikely given the problem constraints.\n",
    "def generateTriangularSequence(n):\n    # If n is less than 1, return an empty list as there are no elements to display.\n    if n < 1:\n        return []\n    # Begin the sequence with the initial elements as per the defined rule.\n    triangularSequence = [1, 3]\n    # Iteratively calculate the values for the sequence from the third element onward.\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            # For even-index elements, use the specific formula for calculation.\n            triangularSequence.append(1 + i // 2)\n        else:\n            # Odd-index elements require checking to avoid accessing an index that doesn't exist.\n            if i + 1 > len(triangularSequence):\n                # Insert a temporary value for calculation purposes.\n                triangularSequence.append(0)  # Temporary placeholder.\n            # Update the placeholder with the correct value based on the sequence rule.\n            triangularSequence[i] = triangularSequence[i - 1] + triangularSequence[i - 2] + triangularSequence[i - 3]\n    return triangularSequence[:n + 1]",
    "def multiplyOddDigits(n):\n    product = 1\n    oddCount = 0\n    for digit in str(n):\n        convertedDigit = int(digit)\n        if convertedDigit % 2 == 1:\n            product *= convertedDigit\n            oddCount += 1\n    if oddCount == 0:\n        return 0\n    return product",
    "def check_nesting(string):\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    # Verifying there are no unmatched '[' indicating incorrect nesting\n    if not stack:\n        # If stack is empty, brackets were properly matched; now ensuring there is actual nesting\n        # Looking for at least one instance of \"[]\" to confirm nesting\n        return '[]' in string\n    return False",
    "import math\n\ndef sum_of_squares(numbers_list):\n    total_squared = 0\n    for number in numbers_list:\n        total_squared += math.ceil(number) ** 2\n    return total_squared",
    "def verify_final_character_is_alphabetic(txt):\n    words = txt.split(' ')\n    last_word = words[-1]\n    return len(last_word) == 1 and 97 <= ord(last_word.lower()) <= 122",
    "def can_rearrange(arr):\n    index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            index = i\n    return index",
    "def find_extreme_integers(lst):\n    negative_numbers = list(filter(lambda x: x < 0, lst))\n    positive_numbers = list(filter(lambda x: x > 0, lst))\n    \n    largest_negative = max(negative_numbers) if negative_numbers else None\n    smallest_positive = min(positive_numbers) if positive_numbers else None\n    \n    return (largest_negative, smallest_positive)",
    "def compare_values(a, b):\n    # Initial setup: Clone inputs for modification\n    cloned_a, cloned_b = a, b\n\n    # Adjusting string inputs: Convert ',' to '.' to allow for float translation\n    if isinstance(cloned_a, str):\n        cloned_a = cloned_a.replace(',', '.')\n    if isinstance(cloned_b, str):\n        cloned_b = cloned_b.replace(',', '.')\n\n    # Evaluating and making a decision\n    if float(cloned_a) == float(cloned_b):  # Translate to float and compare\n        return None  # The values are identical\n    else:\n        # Deliver the original input representing the higher value\n        return a if float(cloned_a) > float(cloned_b) else b",
    "Does the number satisfy the condition of being even and at least eight?",
    "def compute_hyperfactorial(n):\n    factorial_product = 1\n    hyperfactorial = 1\n    for i in range(1, n + 1):\n        factorial_product *= i\n        hyperfactorial *= factorial_product\n    return hyperfactorial",
    "def adjust_spacing(text):\n    adjusted_text = \"\"\n    start_index = 0\n    is_in_space = False\n    \n    for current_index, character in enumerate(text):\n        if character == \" \":\n            if not is_in_space:\n                start_index = current_index\n                is_in_space = True\n        else:\n            if is_in_space:\n                if current_index - start_index == 2:\n                    adjusted_text += \"_\"\n                elif current_index - start_index > 2:\n                    adjusted_text += \"-\"\n                is_in_space = False\n            adjusted_text += character\n    \n    if is_in_space:\n        if len(text) - start_index == 2:\n            adjusted_text += \"_\"\n        elif len(text) - start_index > 2:\n            adjusted_text += \"-\"\n    \n    return adjusted_text",
    "def validate_file_name(file_name):\n    if file_name.count('.') != 1:\n        return 'Invalid'\n    parts = file_name.split('.')\n    prefix, extension = parts[0], parts[1]\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'Invalid'\n    if not prefix or not prefix[0].isalpha():\n        return 'Invalid'\n    digit_count = sum(c.isdigit() for c in prefix)\n    if digit_count > 3:\n        return 'Invalid'\n    return 'Valid'",
    "This function accepts a list of integers. For each element in the list, if its position is divisible by 3, the function squares the number. If the position is divisible by 4 but not by 3, it cubes the number. For all other positions, the number remains unchanged. Ultimately, the function calculates and returns the sum of all the modified elements in the list.\n\nExamples:\n- Given the list [1,2,3], the function will return 6.\n- For an empty list [], it returns 0.\n- With the list [-1,-5,2,-1,-5], the output will be -126.",
    "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)",
    "def simplify(x, n):\n    # Breaking down the fractions to isolate numerators and denominators\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Calculating the product of the numerators and denominators\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n    \n    # Determining if the result is an integer by utilizing the modulo operation\n    return result_num % result_den == 0",
    "def sort_by_sum_of_digits(numbers):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n        \n    return sorted(numbers, key=sum_of_digits)",
    "def countSpecialNumbers(numbers):\n    total = 0\n    odd_digits = (1, 3, 5, 7, 9)\n    for number in numbers:\n        if number > 10:\n            numberAsString = str(number)\n            if int(numberAsString[0]) in odd_digits and int(numberAsString[-1]) in odd_digits:\n                total += 1\n    return total",
    "Calculate the count of unique triples within a series, where the sum of any given triple divided by three results in a whole number, by iterating through a modified series of natural numbers up to a specified limit.",
    "def find_planets_between(planet1, planet2):\n    planets_in_order = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planets_in_order or planet2 not in planets_in_order or planet1 == planet2:\n        return ()\n\n    planet1_position = planets_in_order.index(planet1)\n    planet2_position = planets_in_order.index(planet2)\n    \n    if planet1_position < planet2_position:\n        return planets_in_order[planet1_position + 1:planet2_position]\n    else:\n        return planets_in_order[planet2_position + 1:planet1_position]",
    "def organize_even_strings(lst):\n    \"\"\"Create a function that receives a collection of strings,\n    removes those with odd characters count,\n    and organizes the remainder in ascending order.\n    This collection is strictly composed of strings, not numerical arrays,\n    and might include repeating elements.\n    It should be arranged first by the length of each element, followed by \n    alphabetical sequence for elements of equal length.\n    The function is expected to return this curated and ordered collection of strings.\n    \"\"\"\n    # Step 1: Filter out strings with odd number of characters\n    filtered_list = [string for string in lst if len(string) % 2 == 0]\n\n    # Step 2: Initially sort the strings alphabetically\n    filtered_list.sort()\n    \n    # Step 3: Further sort the filtered list by the length of the strings\n    organized_list = sorted(filtered_list, key=len)\n    \n    return organized_list",
    "A straightforward program that returns the value of x if n is a prime number and returns the value of y in all other cases.\n\nExamples:\n- Calling x_or_y(7, 34, 12) should return 34\n- Calling x_or_y(15, 8, 5) should return 5",
    "Calculate the sum of squares for only those elements in the list that are positive, odd integers.",
    "def calculateDifferences(game, guess):\n    return [abs(x - y) for x, y in zip(game, guess)]",
    "def findStrongestExtension(class_name, extensions):\n    def assessStrength(extension):\n        upperCaseCount = sum(1 for char in extension if char.isupper())\n        lowerCaseCount = sum(1 for char in extension if char.islower())\n        return upperCaseCount - lowerCaseCount\n\n    strongest = extensions[0]\n    maxStrengthValue = assessStrength(strongest)\n    \n    for extension in extensions[1:]:\n        strengthValue = assessStrength(extension)\n        if strengthValue > maxStrengthValue:\n            strongest = extension\n            maxStrengthValue = strengthValue\n            \n    return f\"{class_name}.{strongest}\"",
    "def check_cyclic_pattern(string, pattern):\n    pattern_length = len(pattern)\n    extended_pattern = pattern + pattern\n    for i in range(len(string) - pattern_length + 1):\n        if string[i:i+pattern_length] in extended_pattern:\n            return True\n    return False",
    "def calculate_even_odd_counts(number):\n    even_count, odd_count = 0, 0\n    for digit in str(abs(number)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)",
    "Transform a positive integer into its lowercase Roman numeral form, adhering to the constraint that the number must be between 1 and 1000 inclusive.\n\nFor instance:\n- Converting 19 yields 'xix'.\n- Transforming 152 results in 'clii'.\n- Changing 426 gives 'cdxxvi'.",
    "def isRightAngleTriangle(a, b, c):\n    return a**2 == b**2 + c**2 or b**2 == a**2 + c**2 or c**2 == a**2 + b**2",
    "Identify the longest word with the greatest variety of unique letters.",
    "def consume(amount, requirement, stock):\n    if requirement <= stock:\n        return [amount + requirement, stock - requirement]\n    else:\n        return [amount + stock, 0]",
    "def calculate_algebra(operation, values):\n    formula = str(values[0])\n    for op, num in zip(operation, values[1:]):\n        formula += \" {} {}\".format(op, num)\n    return eval(formula)",
    "def invert_case_if_contains_letters(s):\n    found_letter = False\n    index = 0\n    modified_str = list(s)\n    for char in s:\n        if char.isalpha():\n            modified_str[index] = char.swapcase()\n            found_letter = True\n        index += 1\n    s = ''\n    for char in modified_str:\n        s += char\n    if not found_letter:\n        return s[::-1]\n    else:\n        return s",
    " given string 'text' into its MD5 hash representation. If the input 'text' is empty, it returns None. \n\n```python\nimport hashlib\n\ndef convert_to_md5_hash(text):\n    \"\"\"\n    This function converts a provided string 'text' into its MD5 hash equivalent.\n    If 'text' is an empty string, it returns None instead.\n\n    >>> convert_to_md5_hash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text == '':\n        return None\n    encoded_text = text.encode('ascii')\n    md5_hash = hashlib.md5(encoded_text).hexdigest()\n    return md5_hash\n",
    "The function generate_integers(a, b) finds the even numbers between two given numbers, a and b, within the confines of 2 and 8, and returns a list of these even numbers."
]