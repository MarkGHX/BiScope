[
    "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n    return False",
    "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current_string = []\n    current_depth = 0\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string = []\n\n    return result",
    "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number % 1.0",
    "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False",
    "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    x_mean = sum(numbers) / len(numbers)\n    return sum(abs(x - x_mean) for x in numbers) / len(numbers)",
    "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    result = []\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result",
    "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def parse_paren_group(s: str) -> int:\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif c == ')':\n                depth -= 1\n        return max_depth\n    \n    return [parse_paren_group(x) for x in paren_string.split(' ')]",
    "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain given substring\n    \n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [x for x in strings if substring in x]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_value = 0\n    prod_value = 1\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return (sum_value, prod_value)",
    "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    running_max = None\n    result = []\n    for n in numbers:\n        if running_max is None or n > running_max:\n            running_max = n\n        result.append(running_max)\n    return result",
    "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    s = ''.join(c.lower() for c in string if c.isalnum())  # Normalize the string\n    return s == s[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    if not string:\n        return ''\n    n = len(string)\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string  # This case technically won't be reached due to loop logic",
    "def string_xor(a: str, b: str) -> str:\n    def xor(i: str, j: str) -> str:\n        return '0' if i == j else '1'\n    \n    return ''.join(xor(x, y) for x, y in zip(a, b))",
    "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of a list of strings, return the longest one. Return the first one in case of multiple \n    strings of the same length. Return None in case the input list is empty. \n    >>> longest([])\n    \n    >>> longest(['a', 'b', 'c']) \n    'a' \n    >>> longest(['a', 'bb', 'ccc']) \n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    max_length = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == max_length:\n            return s",
    "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a",
    "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    result = []\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result",
    "def string_sequence(n: int) -> str:\n    return ' '.join([str(x) for x in range(n + 1)])",
    "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))",
    "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[note] for note in music_string.split(' ') if note in note_map]",
    "def how_many_times(string: str, substring: str) -> int:\n    times = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n    return times\n\n# Doctests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    value_map = {\"zero\": 0, \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \n                 \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9}\n    sorted_numbers = sorted(numbers.split(\" \"), key=lambda x: value_map[x])\n    return \" \".join(sorted_numbers)",
    "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = (0, 0)  # Placeholder for the closest pair\n    distance = None  # Placeholder for the minimum distance, None signifies it's not set yet\n    numbers.sort()  # Sort the numbers first to ensure a single pass can find the closest pair\n    \n    # Loop through the list, now in sorted order\n    for i in range(len(numbers) - 1):\n        # Calculate the difference between current and next element\n        current_distance = numbers[i+1] - numbers[i]\n        \n        # Update the closest pair and distance if this is the first pair or a closer pair is found\n        if distance is None or current_distance < distance:\n            distance = current_distance\n            closest_pair = (numbers[i], numbers[i+1])\n            \n    return closest_pair",
    "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]",
    "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [x for x in values if isinstance(x, int)]",
    "def strlen(string: str) -> int:\n    \"\"\"Return the length of a given string\n    \n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in reversed(range(1, n)):\n        if n % i == 0:\n            return i",
    "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    fact = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            fact.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        fact.append(n)\n    return fact",
    "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    c = Counter(numbers)\n    return [n for n in numbers if c[n] == 1]",
    "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return string.swapcase()",
    "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [x for x in strings if x.startswith(prefix)]",
    "def get_positive(l: list) -> list:\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [e for e in l if e > 0]\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for k in range(3, int(n ** 0.5) + 1, 2):\n        if n % k == 0:\n            return False\n    return True",
    "import math\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\" \n    Finds a zero point of a polynomial with coefficients xs.\n    Assumes polynomial has at least one real root and an even number of coefficients.\n    \"\"\"\n    # Initial search interval\n    begin, end = -1.0, 1.0\n    \n    # Expand search interval until sign change\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2\n        end *= 2\n    \n    # Binary search for root\n    while abs(end - begin) > 1e-10:\n        center = (begin + end) / 2\n        if poly(xs, center) * poly(xs, begin) < 0:\n            end = center\n        else:\n            begin = center\n    \n    return (begin + end) / 2\n\n# Test cases in docstring\nif __name__ == \"__main__\":\n    # Running test cases as mentioned in the docstring\n    print(\"Root found (approximation):\", round(find_zero([1, 2]), 2))  # Expected output: -0.5\n    print(\"Root found (approximation):\", round(find_zero([-6, 11, -6, 1]), 2))  # Expected output: 1.0",
    "def sort_third(l: list):\n    l[::3] = sorted(l[::3])\n    return l",
    "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))",
    "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def fizz_buzz(n: int) -> int:\n    ns = [i for i in range(n) if i % 11 == 0 or i % 13 == 0]\n    s = ''.join(str(i) for i in ns)\n    return sum(1 for c in s if c == '7')",
    "def sort_even(l: list):\n    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for i in range(max(len(evens), len(odds))):\n        if i < len(evens):\n            ans.append(evens[i])\n        if i < len(odds):\n            ans.append(odds[i])\n    return ans",
    "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Since encoding the string twice undoes the cyclic permutation, just encode it twice.\n    return encode_cyclic(encode_cyclic(s))",
    "import math\n\ndef prime_fib(n: int):\n    def is_prime(p):\n        if p < 2:\n            return False\n        for i in range(2, int(math.sqrt(p)) + 1):\n            if p % i == 0:\n                return False\n        return True\n\n    f = [0, 1]\n    count = 0\n    \n    while True:\n        if len(f) > 2:\n            f.pop(0)\n        f.append(f[-1] + f[-2])\n        \n        if is_prime(f[-1]):\n            count += 1\n            if count == n:\n                return f[-1]",
    "def triples_sum_to_zero(l: list):\n    n = len(l)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False",
    "def car_race_collision(n: int):\n    return n * n",
    "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [e + 1 for e in l]",
    "def pairs_sum_to_zero(l):\n    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False",
    "def change_base(x: int, base: int) -> str:\n    ret = ''\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret if ret else '0'",
    "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return a * h / 2.0\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def fib4(n: int):\n    if n < 4:\n        return [0, 0, 2, 0][n]\n    \n    results = [0, 0, 2, 0]\n    for i in range(4, n + 1):\n        fib4_n = sum(results)\n        results.pop(0)\n        results.append(fib4_n)\n    \n    return results[-1]",
    "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0",
    "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    text = text.lower().replace(\" \", \"\").replace(\",\", \"\").replace('.', '')\n    for i in range(len(text) // 2):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    ret = 1\n    for _ in range(n):\n        ret = (2 * ret) % p\n    return ret\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])",
    "def remove_vowels(text):\n    return ''.join(s for s in text if s.lower() not in 'aeiou')",
    "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for e in l:\n        if e >= t:\n            return False\n    return True",
    "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y",
    "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)\n\n# Tests\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
    "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)",
    "def correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for char in brackets:\n        if char == \"<\":\n            depth += 1\n        elif char == \">\":\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0",
    "def monotonic(l: list):\n    return l == sorted(l) or l == sorted(l, reverse=True)",
    "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))",
    "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k: int) -> bool:\n        if k < 2:\n            return False\n        for i in range(2, int(k**0.5) + 1):\n            if k % i == 0:\n                return False\n        return True\n    \n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest",
    "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))",
    "def correct_bracketing(brackets: str) -> bool:\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        elif b == \")\":\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0",
    "def derivative(xs: list):\n    return [i*x for i, x in enumerate(xs)][1:]",
    "def fibfib(n: int, memo={0: 0, 1: 0, 2: 1}):\n    if n in memo:\n        return memo[n]\n    memo[n] = fibfib(n-1, memo) + fibfib(n-2, memo) + fibfib(n-3, memo)\n    return memo[n]",
    "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    if s[-1] in \"yY\":\n        count += 1\n    return count\n\n# Test cases\nprint(vowels_count(\"abcde\")) # Should return 2\nprint(vowels_count(\"ACEDY\")) # Should return 3\nprint(vowels_count(\"python\")) # Should return 1\nprint(vowels_count(\"Rhythm\")) # Should return 0\nprint(vowels_count(\"SYZYGY\")) # Should return 1",
    "def circular_shift(x, shift):\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    return s[len(s) - shift:] + s[:len(s) - shift]",
    "def digitSum(s):\n    return sum(ord(char) for char in s if char.isupper())",
    "def fruit_distribution(s, n):\n    lis = []\n    for word in s.split(' '):\n        if word.isdigit():\n            lis.append(int(word))\n    return n - sum(lis)",
    "def pluck(arr):\n    if not arr:  # Check if the array is empty\n        return []\n    evens = list(filter(lambda x: x % 2 == 0, arr))  # Filter out only even values\n    if not evens:  # Check if there are no even values\n        return []\n    min_even = min(evens)  # Find the smallest even value\n    return [min_even, arr.index(min_even)]  # Return the value and its index",
    "def search(lst):\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    return ans",
    "def strange_sort_list(lst):\n    res = []\n    switch = True\n    while lst:\n        if switch:\n            res.append(min(lst))\n            lst.remove(min(lst))\n        else:\n            res.append(max(lst))\n            lst.remove(max(lst))\n        switch = not switch\n    return res",
    "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1.\n    '''\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    else:\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)",
    "def will_it_fly(q, w):\n    # Calculate the sum of elements in the list\n    total_weight = sum(q)\n    \n    # Check if the total weight exceeds the maximum allowed weight\n    if total_weight > w:\n        return False\n    \n    # Check if the list is palindromic\n    i, j = 0, len(q) - 1\n    while i < j:\n        if q[i] != q[j]:\n            return False\n        i += 1\n        j -= 1\n    \n    # If the code reaches this point, the object is both not too heavy and balanced\n    return True",
    "def smallest_change(arr):\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans",
    "def total_match(lst1, lst2):\n    # Initialize total character count for each list\n    l1 = 0\n    l2 = 0\n    \n    # Calculate total characters in lst1\n    for string in lst1:\n        l1 += len(string)\n    \n    # Calculate total characters in lst2\n    for string in lst2:\n        l2 += len(string)\n    \n    # Compare and return the list with fewer characters (or lst1 if equal)\n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2",
    "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for j in range(2, int(n**0.5) + 1):\n            if n % j == 0:\n                return False\n        return True\n\n    for i in range(2, 101):\n        if is_prime(i):\n            for j in range(i + 1, 101):\n                if is_prime(j):\n                    for k in range(j + 1, 101):\n                        if is_prime(k):\n                            if i * j * k == a:\n                                return True\n    return False",
    "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x",
    "def iscube(a):\n    root = round(abs(a) ** (1. / 3))\n    return root ** 3 == abs(a)",
    "def hex_key(num):\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for char in num:\n        if char in primes:\n            total += 1\n    return total",
    "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"",
    "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True",
    "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            grade = 'A+'\n        elif gpa > 3.7:\n            grade = 'A'\n        elif gpa > 3.3:\n            grade = 'A-'\n        elif gpa > 3.0:\n            grade = 'B+'\n        elif gpa > 2.7:\n            grade = 'B'\n        elif gpa > 2.3:\n            grade = 'B-'\n        elif gpa > 2.0:\n            grade = 'C+'\n        elif gpa > 1.7:\n            grade = 'C'\n        elif gpa > 1.3:\n            grade = 'C-'\n        elif gpa > 1.0:\n            grade = 'D+'\n        elif gpa > 0.7:\n            grade = 'D'\n        elif gpa > 0.0:\n            grade = 'D-'\n        else:\n            grade = 'E'\n        letter_grades.append(grade)\n    return letter_grades",
    "def prime_length(string):\n    l = len(string)\n    \n    if l < 2:\n        return False\n    \n    for i in range(2, int(l**0.5) + 1):\n        if l % i == 0:\n            return False\n        \n    return True",
    "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return 18 * (10 ** (n - 2))",
    "def solve(N):\n    sum_of_digits = sum(int(digit) for digit in str(N))\n    return bin(sum_of_digits)[2:]",
    "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)",
    "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n    # For each word, sort the characters by their ASCII values, then join them back into a word\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a string with space as separator\n    return ' '.join(sorted_words)",
    "def get_row(lst, x):\n    coords = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    coords.sort(key=lambda coord: coord[1], reverse=True)\n    coords.sort(key=lambda coord: coord[0])\n    return coords",
    "def sort_array(array):\n    if len(array) == 0:\n        return []\n    return sorted(array, reverse=(array[0] + array[-1]) % 2 == 0)",
    "def encrypt(s):\n    d = 'abcdefghijklmnopqrstuvwxyz'  # Alphabet string\n    out = ''  # Initialize the output string\n    for c in s:  # Loop through each character in the input string\n        if c in d:  # Check if the character is a lowercase letter\n            idx = d.index(c)  # Find the index of the character in the alphabet\n            new_idx = (idx + 4) % 26  # Calculate the new index with wrap-around\n            out += d[new_idx]  # Append the encrypted character to the output string\n        else:\n            out += c  # Append non-alphabet characters unchanged\n    return out",
    "def next_smallest(lst):\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]",
    "import re\n\ndef is_bored(S):\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence.startswith('I ') for sentence in sentences if sentence)\n\n# Example usage:\nprint(is_bored(\"I am bored. This is great! I don\u2019t think so. What? I see.\"))",
    "def any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return (x + y == z) or (x + z == y) or (y + z == x)\n    else:\n        return False",
    "def encode(message):\n    vowels_replace = {vowel: chr(ord(vowel) + 2) for vowel in \"aeiouAEIOU\"}\n    vowels_replace.update({vowel.upper(): chr(ord(vowel.upper()) + 2) for vowel in \"aeiou\"})\n    message = message.swapcase()\n    encoded_message = \"\"\n    for char in message:\n        if char in vowels_replace:\n            encoded_message += vowels_replace[char]\n        else:\n            encoded_message += char\n    return encoded_message",
    "def skjkasdkd(lst):\n    def isPrime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    maxx = -1\n    for num in lst:\n        if isPrime(num) and num > maxx:\n            maxx = num\n\n    if maxx == -1:  # No prime number found\n        return 0\n    else:\n        return sum([int(d) for d in str(maxx)])",
    "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    state = \"start\"\n\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if state == \"start\":\n            if key.isupper():\n                state = \"upper\"\n            elif key.islower():\n                state = \"lower\"\n            else:\n                return False\n        elif state == \"upper\" and not key.isupper():\n            return False\n        elif state == \"lower\" and not key.islower():\n            return False\n\n    return True",
    "def count_up_to(n):\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes",
    "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    # Extracting the unit digit and ensuring they are positive using abs()\n    a, b = abs(a) % 10, abs(b) % 10\n    # Calculating and returning the product of the unit digits\n    return a * b",
    "def count_upper(s):\n    count = 0\n    vowels = 'AEIOU'\n    for i in range(0, len(s), 2):\n        if s[i] in vowels:\n            count += 1\n    return count",
    "from math import ceil, floor\n\ndef closest_integer(value):\n    if not value:\n        return 0\n\n    if '.' in value:\n        value = value.rstrip('0').rstrip('.')\n    \n    try:\n        number = float(value)\n    except ValueError:\n        return 0\n\n    if value.endswith('.5'):\n        if number > 0:\n            return ceil(number)\n        else:\n            return floor(number)\n    else:\n        return round(number)",
    "def make_a_pile(n):\n    return [n + 2*i for i in range(n)]",
    "def words_string(s):\n    if not s:\n        return []\n    s_list = []\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n    return \"\".join(s_list).split()",
    "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 1:\n        y -= 1\n    if y < x:\n        return -1\n    return y",
    "def rounded_avg(n, m):\n    if m < n:\n        return -1\n    summation = sum(range(n, m+1))\n    average = summation / (m - n + 1)\n    rounded_average = round(average)\n    binary_representation = bin(rounded_average)\n    return binary_representation",
    "def unique_digits(x):\n    odd_digit_elements = []\n    for i in x:\n        if all(int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)",
    "def by_length(arr):\n    dic = {1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    new_arr = []\n    arr.sort(reverse=True)\n    for num in arr:\n        try:\n            name = dic[num]\n            new_arr.append(name)\n        except KeyError:\n            pass\n    return new_arr",
    "def f(n):\n    ret = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            x = 1\n            for j in range(1, i+1):\n                x *= j\n            ret.append(x)\n        else:\n            x = 0\n            for j in range(1, i+1):\n                x += j\n            ret.append(x)\n    return ret",
    "def even_odd_palindrome(n):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for number in range(1, n+1):\n        if is_palindrome(number):\n            if number % 2 == 0:\n                even_palindrome_count += 1\n            else:\n                odd_palindrome_count += 1\n\n    return even_palindrome_count, odd_palindrome_count",
    "def count_nums(arr):\n    def digits_sum(n):\n        neg = 1\n        if n < 0:\n            neg = -1\n            n *= -1\n        digits = [int(d) for d in str(n)]\n        digits[0] *= neg\n        return sum(digits)\n\n    return len([x for x in arr if digits_sum(x) > 0])",
    "def move_one_ball(arr):\n    if len(arr) == 0:\n        return True\n    \n    sorted_array = sorted(arr)\n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    \n    my_arr = arr[min_index:] + arr[:min_index]\n    \n    for i in range(len(arr)):\n        if my_arr[i] != sorted_array[i]:\n            return False\n            \n    return True",
    "def exchange(lst1, lst2):\n    odd = 0\n    even = 0\n    for item in lst1:\n        if item % 2 == 1:\n            odd += 1\n    for item in lst2:\n        if item % 2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    else:\n        return \"NO\"",
    "def histogram(test):\n    from collections import Counter\n    \n    if not test.strip():\n        return {}  # Return an empty dictionary if the input string is empty or contains only spaces.\n    \n    dict1 = {}\n    list1 = test.split()\n    \n    # Creating a counter object to count occurrences of each letter.\n    letter_counts = Counter(list1)\n    \n    # Finding the maximum count value.\n    t = max(letter_counts.values())\n    \n    # Filtering letters that have the maximum count and adding them to the dictionary.\n    for letter, count in letter_counts.items():\n        if count == t:\n            dict1[letter] = count\n    \n    return dict1",
    "def reverse_delete(s, c):\n    result_string = \"\".join([char for char in s if char not in c])\n    is_palindrome = result_string == result_string[::-1]\n    return (result_string, is_palindrome)",
    "def odd_count(lst):\n    res = []\n    for arr in lst:\n        n = sum(1 for d in arr if int(d) % 2 == 1)\n        sentence = f\"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n        res.append(sentence)\n    return res",
    "def minSubArraySum(nums):\n    max_sum = s = 0\n    for num in nums:\n        s += -num\n        if s < 0:\n            s = 0\n        if s > max_sum:\n            max_sum = s\n    if max_sum == 0:\n        max_sum = max(-num for num in nums)\n    min_sum = -max_sum\n    return min_sum\n\n# Example usage\nprint(minSubArraySum([2, 3, 4, 1, 2, 4]))  # Output: 1\nprint(minSubArraySum([-1, -2, -3]))  # Output: -6",
    "def max_fill(grid, capacity):\n    import math\n    return sum(math.ceil(sum(arr) / capacity) for arr in grid)",
    "def sort_array(arr):\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))",
    "def select_words(s, n):\n    result = []\n    words = s.split()\n    vowels = 'aeiouAEIOU'\n    for word in words:\n        n_consonants = sum(1 for char in word if char not in vowels)\n        if n_consonants == n:\n            result.append(word)\n    return result",
    "def get_closest_vowel(word):\n    vowels = set(\"aeiouAEIOU\")\n    if len(word) < 3:\n        return \"\"\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    return \"\"",
    "def match_parens(lst):\n\n    def check(s):\n        val = 0\n        for char in s:\n            if char == '(':\n                val += 1\n            else:\n                val -= 1\n            if val < 0:\n                return False\n        return val == 0\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n\n    if check(S1) or check(S2):\n        return 'Yes'\n    else:\n        return 'No'",
    "def maximum(arr, k):\n    if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]",
    "def solution(lst):\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 == 1)",
    "def add_elements(arr, k):\n    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)",
    "def get_odd_collatz(n):\n    odd_collatz = [n] if n % 2 != 0 else []\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n            if n != 1:  # Avoid adding 1 multiple times\n                odd_collatz.append(n)\n    odd_collatz.append(1)  # Ensure 1 is always in the sequence\n    return sorted(odd_collatz)",
    "def valid_date(date):\n    # Strip leading and trailing whitespaces\n    date = date.strip()\n    \n    try:\n        # Split the date string\n        month, day, year = date.split('-')\n        \n        # Convert to integers\n        month = int(month)\n        day = int(day)\n        year = int(year)\n        \n    except:\n        # Return False if an exception occurs\n        return False\n    \n    # Check if the month is valid\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the day based on the month\n    if month in [1, 3, 5, 7, 8, 10, 12] and (day < 1 or day > 31):\n        return False\n    elif month in [4, 6, 9, 11] and (day < 1 or day > 30):\n        return False\n    elif month == 2 and (day < 1 or day > 29):\n        return False\n    \n    # If all checks pass, the date is valid\n    return True",
    "def split_words(txt):\n    # Check for whitespaces\n    if ' ' in txt:\n        return txt.split()\n    # Check for commas\n    elif ',' in txt:\n        return txt.replace(',', ' ').split()\n    # Count specific lowercase letters\n    else:\n        return sum(1 for c in txt if c.islower() and ord(c) % 2 == 0)\n\n# Example usage\nprint(split_words(\"Hello world!\"))  # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"Hello,world!\"))  # \u279e [\"Hello\", \"world!\"]\nprint(split_words(\"abcdef\"))  # \u279e 3",
    "def is_sorted(lst):\n    count_digit = {}\n    for i in lst:\n        if i in count_digit:\n            count_digit[i] += 1\n        else:\n            count_digit[i] = 1\n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if not all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return False\n    return True",
    "def intersection(interval1, interval2):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l + 1\n\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    else:\n        return \"NO\"",
    "def prod_signs(arr):\n    if not arr:\n        return None\n    if 0 in arr:\n        return 0\n    sign_product = (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    sum_abs_values = sum([abs(i) for i in arr])\n    return sign_product * sum_abs_values",
    "def minPath(grid, k):\n    from heapq import heappush, heappop\n    \n    N = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # right, down, left, up\n    start_points = []\n    \n    # Preprocess to find the positions of all the values in the grid.\n    value_to_position = {}\n    for i in range(N):\n        for j in range(N):\n            value_to_position[grid[i][j]] = (i, j)\n\n    def neighbors(r, c):\n        \"\"\"Yields valid neighboring cells.\"\"\"\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < N and 0 <= nc < N:\n                yield nr, nc\n    \n    # Initialize a priority queue with tuples of the form (path_value_list, last_row, last_col)\n    pq = [([[grid[x][y]]], x, y) for x, y in value_to_position.values()]\n    \n    while pq:\n        path, r, c = heappop(pq)\n        if len(path) == k:\n            return path[0]  # The path found with length k.\n        for nr, nc in neighbors(r, c):\n            new_path = path[:]  # Create a copy of the current path.\n            new_path[0].append(grid[nr][nc])\n            if len(new_path[0]) <= k:\n                heappush(pq, (new_path, nr, nc))\n    \n    return []  # In case no path is found, should not happen with given problem constraints.",
    "def tri(n):\n    # If n is less than 1, return an empty list.\n    if n < 1:\n        return []\n    # Initialize the sequence with the first two special cases.\n    my_tri = [1, 3]\n    # For the sequence from 2 to n, calculate the value based on the conditions.\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            # Calculate even indexed values differently as mentioned.\n            my_tri.append(1 + i // 2)\n        else:\n            # Calculate odd indexed values using a different formula.\n            if i + 1 > len(my_tri):  # Check this condition to avoid index out of range.\n                # Append a placeholder for tri(i + 1) since it's needed for calculation.\n                my_tri.append(0)  # Placeholder for tri(i + 1).\n            # Recalculate the previously appended zero with the correct value.\n            my_tri[i] = my_tri[i - 1] + my_tri[i - 2] + my_tri[i - 3]\n    return my_tri[:n + 1]",
    "def digits(n):\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit % 2 == 1:\n            product *= int_digit\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    return product",
    "def is_nested(string):\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    # Checking if there are leftover '[' which indicates a wrong nesting\n    if not stack:\n        # If stack is empty, all brackets were matched, now check if there was a nesting\n        # Counting occurrences of \"[]\" to ensure at least one nesting\n        return '[]' in string\n    return False",
    "import math\n\ndef sum_squares(lst):\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i) ** 2\n    return squared",
    "def check_if_last_char_is_a_letter(txt):\n    elements = txt.split(' ')\n    last_element = elements[-1]\n    return len(last_element) == 1 and 97 <= ord(last_element.lower()) <= 122",
    "def can_arrange(arr):\n    ind = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            ind = i\n    return ind",
    "def largest_smallest_integers(lst):\n    negatives = list(filter(lambda x: x < 0, lst))\n    positives = list(filter(lambda x: x > 0, lst))\n    \n    largest_neg = max(negatives) if negatives else None\n    smallest_pos = min(positives) if positives else None\n    \n    return (largest_neg, smallest_pos)",
    "def compare_one(a, b):\n    # Preparation for comparison: Copy inputs to manipulate\n    temp_a, temp_b = a, b\n\n    # Handling string inputs: Replace ',' with '.' for float conversion\n    if isinstance(temp_a, str):\n        temp_a = temp_a.replace(',', '.')\n    if isinstance(temp_b, str):\n        temp_b = temp_b.replace(',', '.')\n\n    # Comparison and decision-making\n    if float(temp_a) == float(temp_b):  # Convert to float and compare\n        return None  # Values are equal\n    else:\n        # Return the original input which has the greater value\n        return a if float(temp_a) > float(temp_b) else b",
    "def is_equal_to_sum_even(n):\n    return n % 2 == 0 and n >= 8",
    "def special_factorial(n):\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n + 1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact",
    "def fix_spaces(text):\n    new_text = \"\"\n    start = 0\n    in_space = False\n    \n    for end, char in enumerate(text):\n        if char == \" \":\n            if not in_space:\n                start = end\n                in_space = True\n        else:\n            if in_space:\n                if end - start == 2:\n                    new_text += \"_\"\n                elif end - start > 2:\n                    new_text += \"-\"\n                in_space = False\n            new_text += char\n    \n    if in_space:\n        if len(text) - start == 2:\n            new_text += \"_\"\n        elif len(text) - start > 2:\n            new_text += \"-\"\n    \n    return new_text",
    "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    parts = file_name.split('.')\n    prefix, extension = parts[0], parts[1]\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    digit_count = sum(c.isdigit() for c in prefix)\n    if digit_count > 3:\n        return 'No'\n    return 'Yes'",
    "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list,\n    the function shall square the integer entry if its index is a multiple of 3\n    and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3.\n    The function will not change the entries in the list whose indexes are not a multiple of 3 or 4.\n    The function shall then return the sum of all entries.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = [] the output should be 0\n    For lst = [-1,-5,2,-1,-5] the output should be -126\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i % 3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)",
    "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)",
    "def simplify(x, n):\n    # Splitting the fractions to extract numerators and denominators\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Multiplying the numerators and denominators\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n    \n    # Checking if the result is a whole number using modulo\n    return result_num % result_den == 0",
    "def order_by_points(nums):\n    def digits_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n        \n    return sorted(nums, key=digits_sum)",
    "def specialFilter(nums):\n    count = 0\n    odd_digits = (1, 3, 5, 7, 9)\n    for num in nums:\n        if num > 10:\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n    return count",
    "def get_max_triples(n):\n    A = [i*i - i + 1 for i in range(1, n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (A[i] + A[j] + A[k]) % 3 == 0:\n                    ans.append((A[i], A[j], A[k]))\n    return len(ans)",
    "def bf(planet1, planet2):\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    \n    if planet1_index < planet2_index:\n        return planet_names[planet1_index + 1:planet2_index]\n    else:\n        return planet_names[planet2_index + 1:planet1_index]",
    "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \"\"\"\n    # Step 1: Delete odd-length strings\n    new_lst = [x for x in lst if len(x) % 2 == 0]\n\n    # Step 2: Sort the remaining strings alphabetically\n    new_lst.sort()\n    \n    # Step 2(b): Sort the list on the basis of string lengths\n    new_lst = sorted(new_lst, key=len)\n    \n    return new_lst",
    "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n    else:\n        return x",
    "def double_the_difference(lst):\n    return sum(i ** 2 for i in lst if i > 0 and i % 2 != 0 and isinstance(i, int))",
    "def compare(game, guess):\n    return [abs(x - y) for x, y in zip(game, guess)]",
    "def Strongest_Extension(class_name, extensions):\n    def calculate_strength(extension):\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        return CAP - SM\n\n    strong = extensions[0]\n    my_val = calculate_strength(strong)\n    \n    for extension in extensions[1:]:\n        val = calculate_strength(extension)\n        if val > my_val:\n            strong = extension\n            my_val = val\n            \n    return f\"{class_name}.{strong}\"",
    "def cycpattern_check(a, b):\n    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        if a[i:i+l] in pat:\n            return True\n    return False",
    "def even_odd_count(num):\n    even_count, odd_count = 0, 0\n    for i in str(abs(num)):\n        if int(i) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)",
    "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    num = [1000, 900, 500, 400,\n           100, 90, 50, 40,\n           10, 9, 5, 4,\n           1]\n    sym = [\"M\", \"CM\", \"D\", \"CD\",\n           \"C\", \"XC\", \"L\", \"XL\",\n           \"X\", \"IX\", \"V\", \"IV\",\n           \"I\"]\n    \n    i = 12\n    res = \"\"\n    \n    while number:\n        div = number // num[i]\n        number %= num[i]\n        \n        while div:\n            res += sym[i]\n            div -= 1\n        i -= 1\n    \n    return res.lower()",
    "def right_angle_triangle(a, b, c):\n    return a**2 == b**2 + c**2 or b**2 == a**2 + c**2 or c**2 == a**2 + b**2",
    "def find_max(words):\n    sorted_words = sorted(words, key=lambda x: (-len(set(x)), x))\n    return sorted_words[0]",
    "def eat(number, need, remaining):\n    if need <= remaining:\n        return [number + need, remaining - need]\n    else:\n        return [number + remaining, 0]",
    "def do_algebra(operator, operand):\n    expression = str(operand[0])\n    for op, val in zip(operator, operand[1:]):\n        expression += \" {} {}\".format(op, val)\n    return eval(expression)",
    "def solve(s):\n    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = ''\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    else:\n        return s",
    "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text == '':\n        return None\n    encoded_text = text.encode('ascii')\n    md5_hash = hashlib.md5(encoded_text).hexdigest()\n    return md5_hash",
    "def generate_integers(a, b):\n    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n    return [i for i in range(lower, upper+1) if i % 2 == 0]"
]